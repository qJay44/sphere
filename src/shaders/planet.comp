#version 460 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 2) uniform image2D image;

layout(binding = 0) uniform sampler2D heightmap0;
layout(binding = 1) uniform sampler2D heightmap1;

layout(location = 0) uniform float seaLevel;
layout(location = 1) uniform float heightmapScale;
layout(location = 2) uniform float worldRadius;
layout(location = 3) uniform ivec2 offset;

#define PI 3.141592265359f

ivec2 mapSize = imageSize(image) * ivec2(2, 1);

vec3 coordinateToPoint(vec2 coord) {
  return vec3(
    worldRadius * sin(coord.y) * cos(coord.x),
    worldRadius * sin(coord.y) * sin(coord.x),
    worldRadius * cos(coord.y)
  );
}

float getHeightmapValue(ivec2 texCoord) {
  float heightmaps[2] = float[2](
    texture(heightmap0, texCoord - offset).r,
    texture(heightmap1, texCoord - offset).r
  );

  return heightmaps[uint(round(texCoord.x / mapSize.x))];
}

vec3 calculateWorldPoint(ivec2 texCoord) {
  texCoord = (texCoord + mapSize) % mapSize;

  vec2 uv = texCoord / (vec2(mapSize) - 1.f);
  vec2 coord = (uv - 0.5f) * PI * vec2(2.f, 1.f);
  vec3 spherePoint = coordinateToPoint(coord);

  float height = getHeightmapValue(texCoord);
  float worldHeight = worldRadius + (height - seaLevel) * heightmapScale;

  return spherePoint * worldHeight;
}

void main() {
  ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy) + offset;
  vec3 posNorth = calculateWorldPoint(texCoord + ivec2( 0,  1));
  vec3 posSouth = calculateWorldPoint(texCoord + ivec2( 0, -1));
  vec3 posEast  = calculateWorldPoint(texCoord + ivec2( 1,  0));
  vec3 posWest  = calculateWorldPoint(texCoord + ivec2(-1,  0));

  vec3 dirNorth = normalize(posNorth - posSouth);
  vec3 dirEast = normalize(posEast - posWest);
  vec3 normal = normalize(cross(dirNorth, dirEast));

  float height = getHeightmapValue(texCoord);
  imageStore(image, texCoord - offset, vec4(normal, height));
  // imageStore(image, texCoord - offset, vec4(1.f, 0.f, 0.f, 1.f));
}

