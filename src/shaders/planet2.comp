#version 460 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 2) uniform image2D image;

layout(binding = 0) uniform sampler2D heightmap;

layout(location = 0) uniform float seaLevel;
layout(location = 1) uniform float heightmapScale;
layout(location = 2) uniform float worldRadius;

#define PI 3.141592265359f

ivec2 mapSize = imageSize(image);

vec3 calculateWorldPoint(ivec2 texCoord) {
  texCoord = (texCoord + mapSize) % mapSize;

  vec2 uv = vec2(texCoord) / (vec2(mapSize) - 1.f);
  vec2 coord = (uv - 0.5f) * PI * vec2(2.f, 1.f);

  float r = cos(coord.y);
  vec3 spherePoint = vec3(sin(coord.x) * r, sin(coord.y), -cos(coord.x) * r);

  float height = texture(heightmap, uv).r;
  float worldHeight = worldRadius + (height + 20.f) * 12.f;

  return spherePoint * worldHeight;
}

void main() {
  const ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
  vec3 posNorth = calculateWorldPoint(texCoord + ivec2( 0,  1));
  vec3 posSouth = calculateWorldPoint(texCoord + ivec2( 0, -1));
  vec3 posEast  = calculateWorldPoint(texCoord + ivec2( 1,  0));
  vec3 posWest  = calculateWorldPoint(texCoord + ivec2(-1,  0));

  vec3 dirNorth = normalize(posNorth - posSouth);
  vec3 dirEast = normalize(posEast - posWest);
  vec3 normal = normalize(cross(dirNorth, dirEast));

  float height = texture(heightmap, vec2(texCoord) / vec2(mapSize)).r;
  imageStore(image, texCoord, vec4(normal, height));
}

